{"version":3,"sources":["Components/TodoItem.js","Components/TodoHeader.js","Actions/actions.js","Components/TodoFooter.js","Components/TodoList.js","Components/App.js","Reducers/reducer.js","index.js"],"names":["TodoItem","_this$props","this","props","title","completed","handleToggleCompletedTodo","handleDestroyOne","react_default","a","createElement","className","type","defaultChecked","onClick","Component","connect","state","dispatch","TodoHeader","handleChange","event","_this","setState","target","value","handleAddTodo","addTodo","keyCode","placeholder","autoFocus","onChange","onKeyDown","payload","TodoFooter","handleDestroyAllCompletedTodos","NavLink","exact","to","activeClassName","todos","clearCompletedTodos","TodoList","Fragment","Components_TodoHeader","map","todo","Components_TodoItem","key","id","Components_TodoFooter","App","todoList","clickedTodoId","newTodos","deleteTodo","allHandlingProps","Switch","Route","path","render","Components_TodoList","Object","assign","filter","toggleTodo","initialState","todosReducer","arguments","length","undefined","action","newlyEnteredTodo","userId","Math","floor","random","objectSpread","toConsumableArray","concat","newTodosMinusOne","store","createStore","ReactDOM","BrowserRouter","basename","process","es","Components_App","document","getElementById"],"mappings":"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","file":"static/js/main.cf6c4c5c.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo, deleteTodo, toggleTodo } from \"../Actions/actions\"\n\n// pascal case helps with distinguishing from html\n// no state b/c no way to change components with state,; this is just displaying and showing render method\nclass TodoItem extends Component {\n    render() {\n        const { title, completed, handleToggleCompletedTodo, handleDestroyOne } = this.props;\n        return (\n            // it will be completed\n            // <li className={completed && \"completed\"}> // this will make an error\n            // still want something to return even if empty\n            <li className={completed ? \"completed\" : \"\"}>\n                <div className=\"view\">\n                    {/* pass handlers down to children to w/e comp has html tag */}\n                    <input className=\"toggle\" type=\"checkbox\" defaultChecked={completed} onClick={handleToggleCompletedTodo} />\n                    {/* change checked to defaultChecked b/c that's not a react thingy */}\n                    <label>{title}</label>\n                    <button className=\"destroy\" onClick={handleDestroyOne}></button>\n                </div>\n            </li>\n        );\n    };\n};\n\n// put the title stuff?\nconst mapStateToProps = (state) => {\n    return {\n        // title\n    }\n};\n// put the rest\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        // clearCompletedTodos: () => dispatch(clearCompletedTodos())\n    }\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoItem)\n// export default TodoItem;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo } from \"../Actions/actions\" // if it's called index.js, you dont need to add it \n\nclass TodoHeader extends Component {\n    state = {\n        title: \"\"\n    };\n\n    handleChange = event => {\n        this.setState({\n            title: event.target.value\n        })\n    };\n\n    // need to ahndle something with dom, so keep this\n    // because \"editting\" or w/e cause of state, not \"reading\", inside the heder, have null for mSTP; info getting dispatched is w/e you enter \n    handleAddTodo = event => {\n        const { addTodo } = this.props;\n        const { title } = this.state;\n        if (event.keyCode === 13) { // 13 is the code for enter; could also do event.key == \"Enter\"\n            addTodo(title);\n            this.setState({ title: \"\" });\n        };\n    };\n\n    render() {\n        const { title } = this.state;\n        return (\n            <header className=\"header\">\n                <h1>todos</h1>\n                <input className=\"new-todo\" placeholder=\"What needs to be done?\" autoFocus onChange={this.handleChange} onKeyDown={this.handleAddTodo} value={title} />\n                {/* the autoFocus auto sleects that input, so it makes it faster for the user; cAn do for loginbox */}\n            </header>\n        );\n    };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        addTodo: title => dispatch(addTodo(title))\n    }\n};\nexport default connect(null, mapDispatchToProps)(TodoHeader);\n// export default TodoHeader;","// action type constants = dont have to mistype string (vs code doesnt know if it is)\n// the exports are named (when expoted, can only import if spelled the same)\nexport const TOGGLE_TODO = \"TOGGLE_TODO\";\nexport const ADD_TODO = \"ADD_TODO\";\nexport const DELETE_TODO = \"DELETE_TODO\";\nexport const CLEAR_COMPLETED_TODOS = \"CLEAR_COMPLETED_TODOS\";\n\n// action creators; make action objs (always have type prop, which si what reducerswitch is on); fetch reqs will end up going inside (would go before the second{}); defines what will happen\nexport const toggleTodo = (id) => {\n    return {\n        type: TOGGLE_TODO,\n        // what makes actioncreater happen; reducer (in other file) will transform data\n        payload: id\n    }\n};\n// export const toggleTodo = (id) => ({\n//     type: TOGGLE_TODO,\n//     payload: id\n// })\n\nexport const addTodo = (title) => {\n    return {\n        type: ADD_TODO,\n        payload: title\n    }\n};\n\nexport const deleteTodo = (id) => {\n    return {\n        type: DELETE_TODO,\n        payload: id\n    }\n};\n\nexport const clearCompletedTodos = () => {\n    return {\n        type: CLEAR_COMPLETED_TODOS\n    }\n};","import React, { Component } from 'react';\nimport { NavLink } from \"react-router-dom\";\nimport { connect } from 'react-redux';\nimport { clearCompletedTodos } from \"../Actions/actions\" // if it's called index.js, you dont need to add it \n\nclass TodoFooter extends Component {\n    render() {\n        // if dont do this, change this to match the stuff with todos and this.state\n        const { completed, handleDestroyAllCompletedTodos } = this.props;\n        return (\n            <footer className=\"footer\">\n                {/* should be 0 default; change to {completed} */}\n                <span className=\"todo-count\"><strong>{completed}</strong> item(s) left</span>\n                <ul className=\"filters\">\n                    {/* if do NavLink, add in activeClassName=\"selected\" and add exact to each, or if have the switch, just put with / in route; or classname={filter === \"all\"?\"seected\":\"\"} */}\n                    <li><NavLink exact to=\"/\" activeClassName=\"selected\">All</NavLink></li>\n                    <li><NavLink exact to=\"/active\" activeClassName=\"selected\">Active</NavLink></li>\n                    <li><NavLink exact to=\"/completed\" activeClassName=\"selected\">Completed</NavLink></li>\n                </ul>\n                <button className=\"clear-completed\" onClick={handleDestroyAllCompletedTodos}>Clear completed</button>\n            </footer>\n        );\n    };\n};\n\nconst mapStateToProps = (state) => {\n    return {\n        // there is a todos prop on state\n        // todos: state.todos.filter(todo => !todo.completed).length\n        todos: state.todos\n    }\n};\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        // call actionCreater() and dispatch it to the redux reducer; could alwayes just write as cCT() as long as named as same thing as prop in comp above and put in {} inside connect\n        clearCompletedTodos: () => dispatch(clearCompletedTodos())\n    }\n};\n// if export derfault, dont have to use the same name; this one isnt nameed at all\n// connect decides when to call these functions; helps relay stuff into react; dont have to pass down props to mult levels; can modify any state on one comp \nexport default connect(mapStateToProps, mapDispatchToProps)(TodoFooter)\n// export default TodoFooter;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport TodoItem from \"./TodoItem.js\";\n// import todoList from '../todos.json';\nimport TodoHeader from './TodoHeader.js';\nimport TodoFooter from './TodoFooter.js';\n\nclass TodoList extends Component {\n    // state = {\n    //     todos: todoList\n    // };    \n    render() {\n        const { todos, handleAddTodo } = this.props;\n        return (\n            // react.fragment is used when there are multpile big tag things\n            <React.Fragment>\n                <TodoHeader handleAddTodo={handleAddTodo}/>\n                <section className=\"main\">\n                    <ul className=\"todo-list\">\n                        {/* when put in comp state; when inside the map function, it will be a single todo */}\n                        {todos.map(todo => <TodoItem key={todo.id} title={todo.title} completed={todo.completed} handleToggleCompletedTodo={this.props.handleToggleCompletedTodo(todo.id)} handleDestroyOne={this.props.handleDestroyOne(todo.id)} />)}\n                        {/* call the hTCT and pass in the todoid and store inside clickedTodoId var, which causes cTI to be in scope for event function  --> completeTodo can also just be hTCT; it rerenders only 1 when props change */}\n                    </ul>\n                </section>\n                <TodoFooter completed={this.props.completed} handleDestroyAllCompletedTodos={this.props.handleDestroyAllCompletedTodos}/>\n            </React.Fragment>\n        );\n    };\n};\n\nexport default TodoList;","import React, { Component } from 'react';\nimport TodoList from \"./TodoList.js\";\nimport { Switch, Route } from \"react-router-dom\";\nimport todoList from '../todos.json';\nimport { connect } from 'react-redux';\nimport { addTodo, clearCompletedTodos, deleteTodo, toggleTodo } from \"../Actions/actions\"\n\nclass App extends Component {\n  // wont need state b/c redux will have the state stuff \n  state = {\n    todos: todoList\n  };\n\n  // function inside funciton; once called the first time, the first outer funxtion will run and implicitly returns inner function (the event handler); first param is event obj sent from dom; cTI can be accessed inside inner funct\n  handleToggleCompletedTodo = clickedTodoId => event => {\n    // map makes new array to get results in newtodos\n    const newTodos = this.state.todos.map(todo => {\n      // get todo id that matches one was clicked; if this is false, no run\n      if (todo.id === clickedTodoId) {\n        // change completed value/any boolean value (t vs f)\n        todo.completed = !todo.completed;\n      }\n      return todo; // have to return original todo obj\n    });\n    // overwrite todos w/ newtodos\n    this.setState({ todos: newTodos });\n  };\n\n  // will lose these handlers b/c just data and not doing stuffon dom\n  handleDestroyOne = clickedTodoId => event => {\n    this.props.deleteTodo(clickedTodoId);\n    // const newTodos = this.state.todos.filter(todo => {\n    //   if (todo.id === clickedTodoId) {\n    //     return false\n    //   }\n    //   return true;\n    // });\n    // this.setState({ todos: newTodos });\n  };\n\n  // handleDestroyAllCompletedTodos = event => {\n  //   const newTodos = this.state.todos.filter(todo => {\n  //     if (todo.completed === true) {\n  //       return false;\n  //     }\n  //     return true;\n  //   });\n  //   this.setState({\n  //     todos: newTodos\n  //   });\n  // };\n  render() {\n    const { todos } = this.props;\n    const allHandlingProps = {\n      // handleAddTodo: this.handleAddTodo,\n      handleDestroyOne: this.handleDestroyOne,\n      handleToggleCompletedTodo: this.handleToggleCompletedTodo,\n      // handleDestroyAllCompletedTodos: this.handleDestroyAllCompletedTodos,\n      // completed: todos.filter(todo => !todo.completed).length\n    };\n    return (\n      <section className=\"todoapp\">\n        <Switch>\n          <Route exact path=\"/active\" render={props => <TodoList {...props} {...allHandlingProps} todos={todos.filter(todo => !todo.completed)} />} />\n          <Route exact path=\"/completed\" render={props => <TodoList {...props} {...allHandlingProps} todos={todos.filter(todo => todo.completed)} />} />\n          <Route exact path=\"/\" render={props => <TodoList {...props} {...allHandlingProps} todos={todos} />} />\n        </Switch>\n      </section>\n    );\n  };\n};\n\n// cut out all ofr the state stuff above b/c state will be handled by redux \n// this state is entire redux state\nconst mapStateToProps = (state) => {\n  return {\n    todos: state.todoList\n  }\n}\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    deleteTodo: id => dispatch(deleteTodo(id)),\n    toggleTodo: id => dispatch(toggleTodo(id))\n  }\n}\n\n// if export derfault, dont have to use the same name; this one isnt nameed at all\n// connect decides when to call these functions; helps relay stuff into react; dont have to pass down props to mult levels; can modify any state on one comp \nexport default connect(mapStateToProps, mapDispatchToProps)(App)\n// export default App;","import { ADD_TODO, CLEAR_COMPLETED_TODOS, DELETE_TODO, TOGGLE_TODO } from \"../Actions/actions.js\";\nimport todoList from '../todos.json'; // this will get the collection of all the messages and can put in the inital state\n\nconst initialState = {\n    todoList\n};\n\n\nconst todosReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case ADD_TODO:\n            let makeId = Math.floor(Math.random() * 333666999);\n            let newlyEnteredTodo = {\n                userId: 1,\n                id: makeId,\n                title: action.payload,\n                completed: false\n            };\n            // wont be an array because this has to deal with wha the initial sate already looks like \n            return {\n                ...state,\n                todoList: [...state.todoList, newlyEnteredTodo]\n            };\n        case CLEAR_COMPLETED_TODOS:\n            return {\n                ...state,\n                todoList: [...state.todoList, todoList.filter(todo => !todo.completed).length]\n            };\n        case DELETE_TODO:\n            const newTodosMinusOne = todoList.filter(todo => {\n                if (todo.id === action.payload) {\n                    return false\n                }\n                return true;\n            });\n            return {\n                ...state,\n                todoList: newTodosMinusOne\n            };\n        case TOGGLE_TODO:\n            // return {...state, action.todo};\n            break;\n        default:\n            return state;\n    }\n};\n\nexport default todosReducer;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from \"react-router-dom\";\nimport './index.css';\nimport App from './Components/App';\nimport todosReducer from \"./Reducers/reducer.js\";\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\n\nlet store = createStore(todosReducer);\n\nconst Index = () => (\n    <BrowserRouter basename={process.env.PUBLIC_URL}>\n    {/* comp that procides access to connect for any subcomp to be able to access redux store */}\n        <Provider store={store}>\n            <App />\n        </Provider>\n    </BrowserRouter>\n);\n\n// ReactDOM.render(<App />, document.getElementById('root'));\nReactDOM.render(<Index />, document.getElementById('root'));\n// first param has to be component"],"sourceRoot":""}